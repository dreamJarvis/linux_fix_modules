WEBVTT

1
00:00:00.114 --> 00:00:02.697
(upbeat music)

2
00:00:05.460 --> 00:00:07.140
<v Instructor>Next up we have our instance methods,</v>

3
00:00:07.140 --> 00:00:10.227
so again, these are methods that live on each array,

4
00:00:10.227 --> 00:00:12.940
and the first one is display all bun types,

5
00:00:12.940 --> 00:00:15.300
with or using join.

6
00:00:15.300 --> 00:00:16.830
So, what is join?

7
00:00:16.830 --> 00:00:17.663
Let's take a look at it.

8
00:00:17.663 --> 00:00:19.510
We've got our buns, and if we were to

9
00:00:19.510 --> 00:00:21.430
call that join against it,

10
00:00:21.430 --> 00:00:24.000
what it does is it turns the array

11
00:00:24.000 --> 00:00:27.290
into a string joining each item with a comma.

12
00:00:27.290 --> 00:00:28.760
Now join will take an argument,

13
00:00:28.760 --> 00:00:30.320
and that is what you want to join or not.

14
00:00:30.320 --> 00:00:34.260
So if you were to console.log, buns.join,

15
00:00:34.260 --> 00:00:38.530
then we could just grab it with or, then you'll see

16
00:00:38.530 --> 00:00:40.268
egg or wonder or brioche,

17
00:00:40.268 --> 00:00:43.210
so that's how join works.

18
00:00:43.210 --> 00:00:44.990
Next is we have a string

19
00:00:44.990 --> 00:00:47.360
hot dogs, hamburger, sausages, corn,

20
00:00:47.360 --> 00:00:50.979
and they are delimited by a comma.

21
00:00:50.979 --> 00:00:53.450
Pretty common thing that you will see.

22
00:00:53.450 --> 00:00:55.578
Use split to turn it into a,

23
00:00:55.578 --> 00:00:57.430
I'll just say into an array,

24
00:00:57.430 --> 00:00:58.690
not into a string.

25
00:00:58.690 --> 00:00:59.590
So let's do it.

26
00:00:59.590 --> 00:01:02.003
Const food.

27
00:01:04.560 --> 00:01:06.790
So, let's go ahead and say, const foodString,

28
00:01:06.790 --> 00:01:08.390
is equal to that.

29
00:01:08.390 --> 00:01:10.870
Now if you want to turn this into an array,

30
00:01:10.870 --> 00:01:12.560
it's actually not an array method,

31
00:01:12.560 --> 00:01:14.300
it's a string method.

32
00:01:14.300 --> 00:01:16.535
You take a look at our foodString here,

33
00:01:16.535 --> 00:01:19.513
we can just console log foodString.split.

34
00:01:21.390 --> 00:01:23.530
We wanna split it based on what character,

35
00:01:23.530 --> 00:01:24.550
the comma.

36
00:01:24.550 --> 00:01:26.900
Now it will get rid of those commas for us,

37
00:01:26.900 --> 00:01:29.120
which is probably what we want.

38
00:01:29.120 --> 00:01:31.490
And then we go, hot dogs, hamburgers, sausages, corn.

39
00:01:31.490 --> 00:01:34.452
So, split is a pretty common one that I will do.

40
00:01:34.452 --> 00:01:36.958
You can also split things on nothing,

41
00:01:36.958 --> 00:01:40.630
and that will just put every letter into

42
00:01:41.730 --> 00:01:42.563
it's own.

43
00:01:42.563 --> 00:01:45.110
That's very similar to spreading

44
00:01:45.110 --> 00:01:47.600
that we did earlier, and just one like,

45
00:01:47.600 --> 00:01:51.780
little gotcha about split, is that you can think of like,

46
00:01:51.780 --> 00:01:54.693
things like wes bos, and if I were to call split,

47
00:01:57.580 --> 00:01:58.413
it works great.

48
00:01:58.413 --> 00:02:00.780
However, if you have emojis in there,

49
00:02:00.780 --> 00:02:03.550
like a family,

50
00:02:03.550 --> 00:02:04.560
like that,

51
00:02:04.560 --> 00:02:06.350
and you split it.

52
00:02:06.350 --> 00:02:08.617
The, this emoji is actually made up of

53
00:02:08.617 --> 00:02:11.360
several other emojis.

54
00:02:11.360 --> 00:02:13.140
It is made up of the,

55
00:02:13.140 --> 00:02:15.370
I think in this case, the man, the woman,

56
00:02:15.370 --> 00:02:18.470
and the child emoji and what is referred to

57
00:02:18.470 --> 00:02:20.340
as a zero width joiner.

58
00:02:20.340 --> 00:02:22.990
So, that will come in,

59
00:02:22.990 --> 00:02:25.330
if you ever try to split something with an emoji in it,

60
00:02:25.330 --> 00:02:27.430
just something to, there's libraries out there

61
00:02:27.430 --> 00:02:28.830
that'll help you get through that

62
00:02:28.830 --> 00:02:31.600
if you do run into that emoji trouble.

63
00:02:31.600 --> 00:02:35.060
Next, take the last item off toppings with pop.

64
00:02:35.060 --> 00:02:38.050
So we haven't learned what pop does just yet,

65
00:02:38.050 --> 00:02:40.800
but if we take a look at our toppings array,

66
00:02:40.800 --> 00:02:42.920
and we call .pop on it.

67
00:02:42.920 --> 00:02:45.080
What it will do is it will return to us

68
00:02:45.080 --> 00:02:47.860
the last item in the array,

69
00:02:47.860 --> 00:02:50.300
and then if we take a look at toppings,

70
00:02:50.300 --> 00:02:54.210
now you'll see that

71
00:02:54.210 --> 00:02:55.730
it now only has 10 items,

72
00:02:55.730 --> 00:02:57.380
and cheese has been removed.

73
00:02:57.380 --> 00:02:59.210
So it's kind of a handy little one

74
00:02:59.210 --> 00:03:01.590
if you just want to like grab one off

75
00:03:01.590 --> 00:03:03.637
the end of the array and then work with it,

76
00:03:03.637 --> 00:03:05.910
and it will just take it out.

77
00:03:05.910 --> 00:03:10.643
Now you tell me, is that an immutable or a mutable method?

78
00:03:10.643 --> 00:03:14.670
It's a mutable method because it mutates the original array,

79
00:03:14.670 --> 00:03:18.400
it takes it off of the array.

80
00:03:18.400 --> 00:03:20.610
So we, let's go ahead and do that, and store it.

81
00:03:20.610 --> 00:03:25.610
So const.lastItem is equal to toppings.pop.

82
00:03:25.950 --> 00:03:30.890
Console.log(lastItem), cheese.

83
00:03:30.890 --> 00:03:32.330
And put it back with push.

84
00:03:32.330 --> 00:03:35.877
So toppings.push(lastItem).

85
00:03:39.220 --> 00:03:42.943
Let's see what we get, so const t2,

86
00:03:43.950 --> 00:03:45.653
let's see what we get with t2.

87
00:03:46.949 --> 00:03:50.460
We get 11, huh, well what does 11 mean?

88
00:03:50.460 --> 00:03:52.800
Well, when you push an item into an array,

89
00:03:52.800 --> 00:03:55.231
it will return to you the new length of the array

90
00:03:55.231 --> 00:03:57.193
in case you need it.

91
00:03:57.193 --> 00:03:59.480
You don't have to put in a variable if you don't need it,

92
00:03:59.480 --> 00:04:01.720
and in our case we don't care about it,

93
00:04:01.720 --> 00:04:03.847
and we could just console.log(toppings),

94
00:04:04.830 --> 00:04:07.010
and make sure that cheese has been put back.

95
00:04:07.010 --> 00:04:08.373
It has.

96
00:04:08.373 --> 00:04:11.255
Take the first item off toppings with shift,

97
00:04:11.255 --> 00:04:14.246
so kind of like the same thing.

98
00:04:14.246 --> 00:04:19.246
Const firstItem is equal to toppings.shift,

99
00:04:19.990 --> 00:04:23.930
console.log(firstItem), we get mushrooms,

100
00:04:23.930 --> 00:04:25.513
put it back with unshift.

101
00:04:26.390 --> 00:04:27.783
We just take this push,

102
00:04:29.820 --> 00:04:33.070
and change this to unshift,

103
00:04:33.070 --> 00:04:36.427
and replace this lastItem with firstItem.

104
00:04:38.182 --> 00:04:40.440
Do the last four, but immutable

105
00:04:40.440 --> 00:04:42.010
with spreads and new variables.

106
00:04:42.010 --> 00:04:44.883
Okay, we can do that, we know how to do that.

107
00:04:45.720 --> 00:04:49.083
So take the last item off toppings with pop.

108
00:04:50.450 --> 00:04:53.343
How do you take the last item off

109
00:04:53.343 --> 00:04:57.350
without mutating the original one?

110
00:04:57.350 --> 00:05:00.834
So we'll just say const newToppings is equal to,

111
00:05:00.834 --> 00:05:04.830
we'll take the toppings.slice,

112
00:05:04.830 --> 00:05:08.650
we'll start at zero, and we'll go for 10,

113
00:05:08.650 --> 00:05:10.290
but that's kind of cheating, hard-coding it,

114
00:05:10.290 --> 00:05:14.800
so we can say toppings.length minus one?

115
00:05:14.800 --> 00:05:16.320
Or minus two, let's see.

116
00:05:16.320 --> 00:05:20.453
Console.log(newToppings), let's see what we got here.

117
00:05:23.200 --> 00:05:26.700
There we go, cheese is now off, that's what we want.

118
00:05:26.700 --> 00:05:30.280
And then the next one was put it back,

119
00:05:30.280 --> 00:05:32.240
so we can just do this:

120
00:05:32.240 --> 00:05:34.920
let newToppings, and then we'll just say

121
00:05:34.920 --> 00:05:37.813
newtoppings is equal to newToppings,

122
00:05:38.652 --> 00:05:41.526
we'll create a new array, spread it back in,

123
00:05:41.526 --> 00:05:46.230
and then put the last item back on.

124
00:05:46.230 --> 00:05:48.930
So you could reference that

125
00:05:48.930 --> 00:05:53.930
by saying toppings.length minus one.

126
00:05:54.110 --> 00:05:56.040
'Cause we didn't actually, we took it out,

127
00:05:56.040 --> 00:05:57.240
but we didn't store it anywhere,

128
00:05:57.240 --> 00:05:59.770
so if need to reference it, we just need to reference it

129
00:05:59.770 --> 00:06:00.980
from the original toppings array.

130
00:06:00.980 --> 00:06:03.220
So what this does, is it spreads every thing

131
00:06:03.220 --> 00:06:06.930
from newToppings array into the array,

132
00:06:06.930 --> 00:06:09.090
and it adds on that last item there,

133
00:06:09.090 --> 00:06:12.470
and what I'm doing here is I've created a let variable,

134
00:06:12.470 --> 00:06:13.820
and I'm just overwriting it.

135
00:06:13.820 --> 00:06:16.320
I could have left this as a const,

136
00:06:16.320 --> 00:06:17.760
if that were the case, I would have had

137
00:06:17.760 --> 00:06:19.760
to const.newtoppings2, right?

138
00:06:19.760 --> 00:06:21.340
And I would have had to create another variable,

139
00:06:21.340 --> 00:06:24.770
so none of these are best or bad practices,

140
00:06:24.770 --> 00:06:26.861
they're just different ways to go about it,

141
00:06:26.861 --> 00:06:29.670
and that should do it for us.

142
00:06:29.670 --> 00:06:32.363
Oh, I think we're missing a square bracket there,

143
00:06:32.363 --> 00:06:34.810
because that square bracket is for referencing

144
00:06:34.810 --> 00:06:37.520
the index, and this one is for creating the array.

145
00:06:37.520 --> 00:06:39.890
Now console.log(newtoppings),

146
00:06:39.890 --> 00:06:42.070
we should see cheese at the end.

147
00:06:42.070 --> 00:06:43.330
Good.

148
00:06:43.330 --> 00:06:46.542
Then we wanted to add it to the front.

149
00:06:46.542 --> 00:06:49.490
So you want to do exactly the same thing as this,

150
00:06:49.490 --> 00:06:50.869
I won't show you how to do it,

151
00:06:50.869 --> 00:06:52.320
but you do the exact same thing as this,

152
00:06:52.320 --> 00:06:56.626
except you start at one and go for the length,

153
00:06:56.626 --> 00:06:59.420
and then when you add it back in, you put it first,

154
00:06:59.420 --> 00:07:01.720
and you spread after that.

155
00:07:01.720 --> 00:07:06.330
Next, make a copy of the toppings array with .slice.

156
00:07:06.330 --> 00:07:08.910
So how do you make a copy of an array?

157
00:07:08.910 --> 00:07:10.830
Well there's a couple of ways that you could do it,

158
00:07:10.830 --> 00:07:14.663
you could use slice, so const toppingsCopy

159
00:07:17.430 --> 00:07:22.400
is equal to toppings.slice, start for zero,

160
00:07:22.400 --> 00:07:25.472
I think, do we need the second argument?

161
00:07:25.472 --> 00:07:26.943
Let's look it up!

162
00:07:29.280 --> 00:07:30.473
Slice.

163
00:07:35.400 --> 00:07:38.763
Going to the sidebar here, click over to slice.

164
00:07:39.990 --> 00:07:43.577
Method returns a shallow copy of the portion of the array

165
00:07:43.577 --> 00:07:46.370
and the new object from beginning to end

166
00:07:46.370 --> 00:07:47.990
end not included.

167
00:07:47.990 --> 00:07:50.682
So we go down to here, the end is optional, zero based,

168
00:07:50.682 --> 00:07:53.329
slice extracts up to, but not including end.

169
00:07:53.329 --> 00:07:56.900
If end is omitted, slice extracts through the end

170
00:07:56.900 --> 00:07:58.780
of the sequence, okay, so we don't need it.

171
00:07:58.780 --> 00:07:59.913
Just slice zero,

172
00:08:00.820 --> 00:08:03.417
and console.log (toppingsCopy).

173
00:08:08.460 --> 00:08:09.610
Looks good!

174
00:08:09.610 --> 00:08:11.711
The way we can tell if that is a copy,

175
00:08:11.711 --> 00:08:15.030
is if we were to change the original toppings,

176
00:08:15.030 --> 00:08:20.030
so toppings, square brackets, zero, equals Mushy Boi,

177
00:08:22.120 --> 00:08:25.130
and we were to console.log both the toppings

178
00:08:25.130 --> 00:08:27.240
and the toppingsCopy.

179
00:08:27.240 --> 00:08:29.530
The toppings says Mushy Boi

180
00:08:29.530 --> 00:08:34.100
but the copy that made is only Mushrooms.

181
00:08:34.100 --> 00:08:37.040
So you see that this made a true copy.

182
00:08:37.040 --> 00:08:39.088
Second one is make a copy of the toppings array

183
00:08:39.088 --> 00:08:43.117
with a spread, so const toppingsCopy2

184
00:08:44.430 --> 00:08:48.523
is equal to, just make a new array, and ...toppings.

185
00:08:51.419 --> 00:08:54.030
I kind of like that, I like using spreads a lot,

186
00:08:54.030 --> 00:08:57.410
it's kind of weird at first, because of the ...,

187
00:08:57.410 --> 00:08:59.860
maybe the syntax is a little bit funky to you,

188
00:08:59.860 --> 00:09:01.790
but I think once you understand

189
00:09:01.790 --> 00:09:05.430
like what's actually going on there, and how spreads work

190
00:09:05.430 --> 00:09:07.390
then you're in good shape.

191
00:09:07.390 --> 00:09:11.290
Take out items three to five of your new toppings array.

192
00:09:11.290 --> 00:09:16.290
Okay, so let's say, toppingsCopy.splice,

193
00:09:17.470 --> 00:09:20.636
because that is destructive, it is mutable,

194
00:09:20.636 --> 00:09:25.636
we want to go three to five, and console.log(toppingsCopy).

195
00:09:30.620 --> 00:09:32.030
Mushrooms, tomatoes, eggs,

196
00:09:32.030 --> 00:09:34.972
we've got three to five being spliced out.

197
00:09:34.972 --> 00:09:38.250
Find the index of avocado with indexof.

198
00:09:38.250 --> 00:09:42.072
So previously, we had looked for an item with just find,

199
00:09:42.072 --> 00:09:46.820
but if they are simply just strings, or numbers,

200
00:09:46.820 --> 00:09:49.160
or references to an object, if you know exactly

201
00:09:49.160 --> 00:09:52.430
what you're looking for, indexof is going to do

202
00:09:52.430 --> 00:09:53.290
what you want to do.

203
00:09:53.290 --> 00:09:57.623
So const index is equal to, let's call it avoIndex,

204
00:10:01.346 --> 00:10:05.096
toppings.indexOf('Avocado').

205
00:10:11.667 --> 00:10:14.917
Console.log(avoIndex).

206
00:10:15.826 --> 00:10:18.932
Five, okay it tells me it's the fifth one in there.

207
00:10:18.932 --> 00:10:22.870
One kind of thing about indexOf that you should know

208
00:10:22.870 --> 00:10:26.240
is that it works with any types,

209
00:10:26.240 --> 00:10:31.240
so if I've got a const people is equal to, square brackets,

210
00:10:36.760 --> 00:10:41.760
and I have objects here, maybe if I do const wes is equal to

211
00:10:42.560 --> 00:10:46.900
right here, name is wes, and then I hard code

212
00:10:46.900 --> 00:10:49.970
one in here as well, so name is Scott,

213
00:10:49.970 --> 00:10:53.684
and then I just put wes in the array as well.

214
00:10:53.684 --> 00:10:55.100
Let's see what we got here.

215
00:10:55.100 --> 00:11:00.100
We've got people, there's two people in there.

216
00:11:00.230 --> 00:11:02.480
Now if I were to console.log(people.indexOf),

217
00:11:04.930 --> 00:11:07.123
and I were to say wes,

218
00:11:09.250 --> 00:11:11.590
it tells me wes is at one,

219
00:11:11.590 --> 00:11:14.290
because it is giving reference to that object.

220
00:11:14.290 --> 00:11:17.030
Now if I were to say people.indexOf,

221
00:11:18.860 --> 00:11:23.070
and we were to pass it an object where the name

222
00:11:23.070 --> 00:11:27.220
is equal to Scott, so exactly as I typed it here,

223
00:11:27.220 --> 00:11:29.280
it tells you negative one, and negative one

224
00:11:29.280 --> 00:11:31.340
is when it didn't find anything, and the reason

225
00:11:31.340 --> 00:11:32.173
it doesn't give you zero

226
00:11:32.173 --> 00:11:33.900
is because zero would be the first thing.

227
00:11:33.900 --> 00:11:36.310
So negative one means it didn't find anything.

228
00:11:36.310 --> 00:11:41.310
So why did it work when I pass it an object,

229
00:11:41.729 --> 00:11:45.410
but it doesn't work when I pass it an object

230
00:11:45.410 --> 00:11:46.796
that is exactly the same, and that

231
00:11:46.796 --> 00:11:51.640
is because even though these objects

232
00:11:51.640 --> 00:11:53.820
may look exactly the same,

233
00:11:53.820 --> 00:11:55.970
they are not the exact same thing,

234
00:11:55.970 --> 00:12:00.970
so if I were to say wes is equal to my object of wes,

235
00:12:01.000 --> 00:12:04.880
we get, oh I have to put that in, a variable,

236
00:12:04.880 --> 00:12:09.880
so const wes2, so wes2 is the same thing as wes,

237
00:12:10.827 --> 00:12:15.827
but they are not equal to each other, false.

238
00:12:15.860 --> 00:12:16.693
Why?

239
00:12:16.693 --> 00:12:20.010
Because objects don't do a deep check for all the properties

240
00:12:20.010 --> 00:12:22.480
to line up, they just check if the reference,

241
00:12:22.480 --> 00:12:25.120
if it is actually the same object.

242
00:12:25.120 --> 00:12:30.120
So in the case of this, indexOf(wes) checks for

243
00:12:30.140 --> 00:12:32.415
if this object is the exact same object in here,

244
00:12:32.415 --> 00:12:35.630
whereas when I just checked it for an object

245
00:12:35.630 --> 00:12:38.080
that looked exactly the same, it gave me false,

246
00:12:38.080 --> 00:12:41.450
so that's the whole reference versus value thing again.

247
00:12:41.450 --> 00:12:44.480
It's just to make sure that you know that,

248
00:12:44.480 --> 00:12:45.910
if that's what you're looking for,

249
00:12:45.910 --> 00:12:46.990
someone with the name of Scott,

250
00:12:46.990 --> 00:12:49.157
then you have to use find with a callback.

251
00:12:49.157 --> 00:12:52.980
So I'm going to remove that just because it's a bit further.

252
00:12:52.980 --> 00:12:54.744
We also have lastIndexOf if you want to find

253
00:12:54.744 --> 00:12:56.280
the last instance.

254
00:12:56.280 --> 00:12:58.863
IndexOf will find you the first instance of it.

255
00:13:00.840 --> 00:13:03.600
Check if hot sauce is in the topping with includes.

256
00:13:03.600 --> 00:13:06.364
So includes is pretty cool, you just take an array,

257
00:13:06.364 --> 00:13:10.080
and one, two, three, four, and you can call includes on it,

258
00:13:10.080 --> 00:13:12.240
you can check if it includes a number,

259
00:13:12.240 --> 00:13:15.140
and it will tell you if that number, or if that string,

260
00:13:15.140 --> 00:13:18.900
or if that reference to an object is in the array.

261
00:13:18.900 --> 00:13:20.833
So we can simply go right here,

262
00:13:22.733 --> 00:13:24.233
const isInToppings is equal to

263
00:13:28.749 --> 00:13:30.610
toppings.includes,

264
00:13:30.610 --> 00:13:33.153
we want to check if it has hot sauce.

265
00:13:34.170 --> 00:13:37.040
And by the way, includes is not case sensitive,

266
00:13:37.040 --> 00:13:39.900
so if you were checking for all different versions

267
00:13:39.900 --> 00:13:42.060
of the case, what you would want to do

268
00:13:42.060 --> 00:13:44.300
is first lowercase the entire array,

269
00:13:44.300 --> 00:13:46.650
and we'll look at how to do that with map

270
00:13:46.650 --> 00:13:48.860
in the next couple videos.

271
00:13:48.860 --> 00:13:53.790
So console.log(isInToppings), it should give us false.

272
00:13:53.790 --> 00:13:56.660
There, it does, and then add it if it is not.

273
00:13:56.660 --> 00:13:59.503
So if, bang (!), isInToppings,

274
00:13:59.503 --> 00:14:01.703
so if it is not in the toppings,

275
00:14:01.703 --> 00:14:03.647
then toppings.push('Hot Sauce').

276
00:14:06.300 --> 00:14:08.780
And then we'll console.log(toppings),

277
00:14:08.780 --> 00:14:11.360
make sure we have hot sauce now added to the end.

278
00:14:11.360 --> 00:14:13.050
Beautiful, we do!

279
00:14:13.050 --> 00:14:15.330
And then flip around toppings with a reverse.

280
00:14:15.330 --> 00:14:17.890
So we know that there's two ways to reverse,

281
00:14:17.890 --> 00:14:20.740
we can just call toppings.reverse,

282
00:14:20.740 --> 00:14:23.560
and that is a mutatable method,

283
00:14:23.560 --> 00:14:28.560
meaning it will reverse the toppings array for us.

284
00:14:28.625 --> 00:14:31.130
So you see here, Mushy Boi is first,

285
00:14:31.130 --> 00:14:35.610
but then after we switch it around, Mushy Boi is last.

286
00:14:35.610 --> 00:14:37.320
And then what's the other way?

287
00:14:37.320 --> 00:14:40.281
If you want to make an immutable version of it,

288
00:14:40.281 --> 00:14:42.140
if you don't want to actually reverse

289
00:14:42.140 --> 00:14:44.680
the original toppings array, we can create a new array,

290
00:14:44.680 --> 00:14:47.110
which is const toppingsReversed,

291
00:14:48.690 --> 00:14:51.417
we can take a copy of it with our spread,

292
00:14:51.417 --> 00:14:54.920
and then just call reverse on that.

293
00:14:54.920 --> 00:14:57.700
And that will make sure, just watch this,

294
00:14:57.700 --> 00:14:59.802
if I console.log(toppings),

295
00:14:59.802 --> 00:15:02.407
comment out this original reverse,

296
00:15:02.407 --> 00:15:04.717
the toppings are still in the right order,

297
00:15:04.717 --> 00:15:08.590
but our toppingsReversed should be backwards.

298
00:15:08.590 --> 00:15:10.050
It is!

299
00:15:10.050 --> 00:15:13.870
So hopefully that whole concept of immutable and mutable

300
00:15:13.870 --> 00:15:15.380
is starting to set in.

301
00:15:15.380 --> 00:15:17.240
So those are all the methods

302
00:15:17.240 --> 00:15:18.770
that I think are going to be helpful.

303
00:15:18.770 --> 00:15:20.520
There's a couple other ones here and there,

304
00:15:20.520 --> 00:15:22.290
you can look at the whole list,

305
00:15:22.290 --> 00:15:24.210
but almost all of these

306
00:15:24.210 --> 00:15:27.510
are going to be callback methods,

307
00:15:27.510 --> 00:15:29.570
or filtering methods.

308
00:15:29.570 --> 00:15:32.320
So let's talk about callback methods in the next video.

