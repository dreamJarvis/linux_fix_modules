WEBVTT

1
00:00:00.583 --> 00:00:03.166
(upbeat music)

2
00:00:05.600 --> 00:00:07.130
<v Instructor>If statements are the foundation</v>

3
00:00:07.130 --> 00:00:08.840
of all logic in JavaScript,

4
00:00:08.840 --> 00:00:11.890
they expect Boolean, which is we've learned earlier.

5
00:00:11.890 --> 00:00:13.360
That's a type in JavaScript

6
00:00:13.360 --> 00:00:16.450
that is always either true or false.

7
00:00:16.450 --> 00:00:19.110
Or they expect some sort of condition

8
00:00:19.110 --> 00:00:22.050
that is evaluated to true or false,

9
00:00:22.050 --> 00:00:24.230
or we're gonna learn about these kind of neat concepts

10
00:00:24.230 --> 00:00:25.790
called truthy and falsy.

11
00:00:25.790 --> 00:00:28.030
I gonna explain the mechanics of an if statements

12
00:00:28.030 --> 00:00:30.930
with greater or less than operators right now,

13
00:00:30.930 --> 00:00:32.980
but we're gonna go in deeper into a whole bunch

14
00:00:32.980 --> 00:00:34.920
of different operators in just a second.

15
00:00:34.920 --> 00:00:37.420
So at its most basic, we have an if statement.

16
00:00:37.420 --> 00:00:38.253
It looks like this.

17
00:00:38.253 --> 00:00:41.000
If 10 is greater than two, then go ahead and console log.

18
00:00:41.000 --> 00:00:43.050
Yep, we've looked at a couple of those so far.

19
00:00:43.050 --> 00:00:45.170
So we this is the if statement.

20
00:00:45.170 --> 00:00:48.580
This is what is referred to as the condition.

21
00:00:48.580 --> 00:00:51.040
The condition is going to be evaluated

22
00:00:51.040 --> 00:00:52.940
to either true or false.

23
00:00:52.940 --> 00:00:54.260
And by evaluate I mean

24
00:00:54.260 --> 00:00:57.350
if you were to take that outside of that and just run it,

25
00:00:57.350 --> 00:00:59.910
it's either going to give you true or false.

26
00:00:59.910 --> 00:01:03.490
There is nothing else that could ever be returned from that.

27
00:01:03.490 --> 00:01:06.140
Now that statement can also be truthy or falsy.

28
00:01:06.140 --> 00:01:07.620
We'll talk about that in a second.

29
00:01:07.620 --> 00:01:09.100
Then we have what is called

30
00:01:09.100 --> 00:01:10.620
and you probably know what this is.

31
00:01:10.620 --> 00:01:13.320
Curly brackets are opening and closing a block.

32
00:01:13.320 --> 00:01:15.470
So any code that needs to happen

33
00:01:15.470 --> 00:01:18.250
when this is true will go inside of here.

34
00:01:18.250 --> 00:01:20.060
We can also add an else if.

35
00:01:20.060 --> 00:01:23.290
So you say else if and note that there's a space there.

36
00:01:23.290 --> 00:01:26.540
I know a lot of programming languages do elseif,

37
00:01:26.540 --> 00:01:29.030
or some do both like PHP,

38
00:01:29.030 --> 00:01:32.720
but it's in JavaScript, it's always two words else if.

39
00:01:32.720 --> 00:01:35.610
And then we can have another condition here.

40
00:01:35.610 --> 00:01:38.720
So we'll say 11 is greater than 10,

41
00:01:38.720 --> 00:01:43.180
then we'll go ahead and open up another block

42
00:01:43.180 --> 00:01:46.263
can put whatever you want inside of there as well.

43
00:01:47.410 --> 00:01:51.710
You can also change your else if as long as you wish to go.

44
00:01:51.710 --> 00:01:55.180
So if I did another one else if

45
00:01:55.180 --> 00:01:57.450
and some people like to prefer

46
00:01:57.450 --> 00:01:59.620
to put these on their own lines.

47
00:01:59.620 --> 00:02:01.720
I prefer to put them on the line

48
00:02:01.720 --> 00:02:04.410
with the closing curly bracket of the previous one,

49
00:02:04.410 --> 00:02:05.850
just for readability sake.

50
00:02:05.850 --> 00:02:08.453
That way it keeps it on one line nice and clean.

51
00:02:09.460 --> 00:02:12.940
You can do three is greater than one.

52
00:02:12.940 --> 00:02:14.710
And obviously this will never be reached

53
00:02:14.710 --> 00:02:16.480
cause the first one will be true.

54
00:02:16.480 --> 00:02:20.240
And actually that that is a good point right there.

55
00:02:20.240 --> 00:02:22.710
If the first one is true,

56
00:02:22.710 --> 00:02:26.400
even if ones that come later are also true,

57
00:02:26.400 --> 00:02:27.740
they will never run.

58
00:02:27.740 --> 00:02:31.130
So if you look at this, all of these are going to be true.

59
00:02:31.130 --> 00:02:32.433
They only get Yep.

60
00:02:33.340 --> 00:02:37.490
Like what Yep one. Yep two, and Yep three.

61
00:02:37.490 --> 00:02:39.600
We're only ever going to get Yep one.

62
00:02:39.600 --> 00:02:42.500
Why because as soon as an if statement

63
00:02:42.500 --> 00:02:45.320
finds itself to be true,

64
00:02:45.320 --> 00:02:46.228
it says, I undone here

65
00:02:46.228 --> 00:02:51.228
and it'll go on to only, it will skip the rest

66
00:02:51.360 --> 00:02:53.160
of the if statement,

67
00:02:53.160 --> 00:02:56.180
and will go on to whatever code is underneath it.

68
00:02:56.180 --> 00:02:59.550
If you wish to check for multiple things that are true,

69
00:02:59.550 --> 00:03:01.920
like in this case all three of them are true.

70
00:03:01.920 --> 00:03:03.180
If that was the case,

71
00:03:03.180 --> 00:03:06.240
you'd have to have three separate if statements,

72
00:03:06.240 --> 00:03:09.340
rather than one big else if statement.

73
00:03:09.340 --> 00:03:10.610
And in a lot of cases

74
00:03:10.610 --> 00:03:13.850
where you could either do either one or the other,

75
00:03:13.850 --> 00:03:15.800
I prefer just to do separate if statements,

76
00:03:15.800 --> 00:03:17.760
just for readability sake.

77
00:03:17.760 --> 00:03:19.570
Additionally, if nothing is match,

78
00:03:19.570 --> 00:03:22.160
you can change a dot else on to the end.

79
00:03:22.160 --> 00:03:23.940
So let me get rid of this here.

80
00:03:23.940 --> 00:03:26.673
And let's make a variable called age.

81
00:03:30.100 --> 00:03:34.983
Let's say 50, and we'll say if the age is greater than 70,

82
00:03:36.160 --> 00:03:38.613
and console log in your 70s,

83
00:03:38.613 --> 00:03:42.913
then else if age is greater than 60,

84
00:03:44.260 --> 00:03:45.093
then

85
00:03:46.060 --> 00:03:47.450
and what I like to do here

86
00:03:47.450 --> 00:03:49.040
is just duplicate all these lines

87
00:03:49.040 --> 00:03:51.293
and change out the only parts that you need.

88
00:03:52.410 --> 00:03:56.140
Boom, I got an extra curly bracket there is greater than 50

89
00:03:57.510 --> 00:03:59.620
and your 50s.

90
00:03:59.620 --> 00:04:01.765
And then Finally if nothing is true,

91
00:04:01.765 --> 00:04:03.250
we're going to say else.

92
00:04:03.250 --> 00:04:04.683
And then console log,

93
00:04:07.230 --> 00:04:09.310
nothing was true.

94
00:04:09.310 --> 00:04:12.290
You'll notice that there is no else parenthese here.

95
00:04:12.290 --> 00:04:14.850
That's because in else never has a condition,

96
00:04:14.850 --> 00:04:17.010
and else's just sort of worst case scenario

97
00:04:17.010 --> 00:04:17.870
at the end of the line,

98
00:04:17.870 --> 00:04:19.300
if nothing was true.

99
00:04:19.300 --> 00:04:22.360
Then run me similar to the default

100
00:04:22.360 --> 00:04:24.400
that we learned about in our switch statement.

101
00:04:24.400 --> 00:04:26.410
And now you'll see nothing is true,

102
00:04:26.410 --> 00:04:28.860
it will finally run over to this.

103
00:04:28.860 --> 00:04:31.520
Now if I take a look at this example here,

104
00:04:31.520 --> 00:04:35.410
and if I make it 100 just like we've said,

105
00:04:35.410 --> 00:04:36.683
what are we going to get?

106
00:04:37.880 --> 00:04:39.730
We get you're in your 70s.

107
00:04:39.730 --> 00:04:41.230
That may kind of make sense,

108
00:04:41.230 --> 00:04:43.440
but even though these are also true,

109
00:04:43.440 --> 00:04:46.498
like I said before, the first thing that is true,

110
00:04:46.498 --> 00:04:48.800
is the one that is going to trip.

111
00:04:48.800 --> 00:04:52.050
So if you are doing multiple things that could be true,

112
00:04:52.050 --> 00:04:55.180
then you need to be aware of the order in which you check

113
00:04:55.180 --> 00:04:56.593
for your if statements.

114
00:04:57.510 --> 00:04:59.880
Now let's talk about if statements inside of functions,

115
00:04:59.880 --> 00:05:01.600
cause it's likely that we're going to use

116
00:05:01.600 --> 00:05:03.090
an if statement inside of a function

117
00:05:03.090 --> 00:05:04.910
to return different values.

118
00:05:04.910 --> 00:05:08.410
So let's create a little function called slugify.

119
00:05:08.410 --> 00:05:11.310
It's gonna paste in this slugify function that we have here.

120
00:05:11.310 --> 00:05:13.150
Let's go through what it does real quick.

121
00:05:13.150 --> 00:05:14.580
You can go ahead and type this up

122
00:05:14.580 --> 00:05:17.090
or grab it from the answer.

123
00:05:17.090 --> 00:05:19.670
We've got our function slugify, it takes in a sentence

124
00:05:19.670 --> 00:05:22.010
and then it's going to take in a Boolean

125
00:05:22.010 --> 00:05:24.120
which is either gonna be true or false

126
00:05:24.120 --> 00:05:26.540
of whether we should lowercase it or not.

127
00:05:26.540 --> 00:05:28.900
Then what we do is we return that sentence,

128
00:05:28.900 --> 00:05:31.410
but we call the dot replace method on it.

129
00:05:31.410 --> 00:05:33.020
Now this, what is this?

130
00:05:33.020 --> 00:05:37.370
This is what is referred to as a Regex a regular expression.

131
00:05:37.370 --> 00:05:41.348
A regular expression is a way to match characters

132
00:05:41.348 --> 00:05:43.060
in some text

133
00:05:43.060 --> 00:05:44.675
and the

134
00:05:44.675 --> 00:05:47.690
this regex what it will do a regex is always starts

135
00:05:47.690 --> 00:05:50.230
and closes with a forward slash.

136
00:05:50.230 --> 00:05:53.630
And then you can type in different characters in here.

137
00:05:53.630 --> 00:05:56.340
In our case we wanna pass the space character

138
00:05:56.340 --> 00:06:00.300
which is forward slash s, and then the g means global.

139
00:06:00.300 --> 00:06:02.720
That means find them all, not just the first one.

140
00:06:02.720 --> 00:06:04.510
And then we replace it with the dash

141
00:06:04.510 --> 00:06:05.800
and we run to lowercase.

142
00:06:05.800 --> 00:06:07.210
Now if I run that,

143
00:06:07.210 --> 00:06:08.630
you see that it just slugfies it.

144
00:06:08.630 --> 00:06:10.980
It put some dashes where spaces where.

145
00:06:10.980 --> 00:06:14.260
Now if we were to run that with a second argument,

146
00:06:14.260 --> 00:06:16.600
which is true,

147
00:06:16.600 --> 00:06:20.790
then it will lowercase that as well.

148
00:06:20.790 --> 00:06:23.250
Now, some developers, myself included,

149
00:06:23.250 --> 00:06:27.060
prefer to keep as much logic out of these brackets

150
00:06:27.060 --> 00:06:30.500
as possible, because I inevitably delete one by accident,

151
00:06:30.500 --> 00:06:33.940
and then my whole day is ruined when you try to run it.

152
00:06:33.940 --> 00:06:35.680
So what you can do

153
00:06:35.680 --> 00:06:37.810
is you can just get rid of this house here

154
00:06:40.240 --> 00:06:41.470
and run the code like that.

155
00:06:41.470 --> 00:06:44.183
Now is that going to be the same thing?

156
00:06:46.950 --> 00:06:47.783
It is!

157
00:06:47.783 --> 00:06:51.090
And the reason that it's the same thing is that

158
00:06:51.090 --> 00:06:53.228
is because of this return keyword here.

159
00:06:53.228 --> 00:06:55.410
Now, what does return mean?

160
00:06:55.410 --> 00:06:58.690
Well, return means to return a value from a function

161
00:06:58.690 --> 00:07:02.320
and stop that function from running.

162
00:07:02.320 --> 00:07:05.160
Because whenever you return from a function,

163
00:07:05.160 --> 00:07:07.860
even if it's inside of an if statement,

164
00:07:07.860 --> 00:07:09.720
that function will stop running

165
00:07:09.720 --> 00:07:12.460
and this code will never be reachable.

166
00:07:12.460 --> 00:07:14.520
So rather than having an if else,

167
00:07:14.520 --> 00:07:16.130
you can simply just have an if,

168
00:07:16.130 --> 00:07:18.060
and then the else is sort of assumed

169
00:07:18.060 --> 00:07:19.360
by you putting it down here.

170
00:07:19.360 --> 00:07:20.550
That's personal preference.

171
00:07:20.550 --> 00:07:23.070
There's no sort of best way to do it.

172
00:07:23.070 --> 00:07:27.050
I just prefer to have an if statement, and then my else,

173
00:07:27.050 --> 00:07:29.680
maybe just put at a little comment there

174
00:07:29.680 --> 00:07:31.590
else and you can put all of the code

175
00:07:31.590 --> 00:07:33.940
that is in the house right down there.

176
00:07:33.940 --> 00:07:35.810
Now, we could have also done something like this.

177
00:07:35.810 --> 00:07:36.880
There's so many different ways

178
00:07:36.880 --> 00:07:37.990
we could have coded this function.

179
00:07:37.990 --> 00:07:39.350
We could have say

180
00:07:39.350 --> 00:07:43.210
let the slug is equal to and we take the sentence

181
00:07:43.210 --> 00:07:44.100
and replace it

182
00:07:46.190 --> 00:07:47.430
here

183
00:07:47.430 --> 00:07:48.860
and then we could have said,

184
00:07:48.860 --> 00:07:53.860
if it's lowercase, slug is equal to slug dot to lower case,

185
00:07:55.220 --> 00:07:56.630
and then at the end of the function,

186
00:07:56.630 --> 00:07:59.470
simply just return slug.

187
00:07:59.470 --> 00:08:02.040
Right now exact Same way to do it.

188
00:08:02.040 --> 00:08:04.730
And then if this is the case, we create a variable.

189
00:08:04.730 --> 00:08:07.250
If it is lowercase, we update that variable,

190
00:08:07.250 --> 00:08:08.440
and then we return it.

191
00:08:08.440 --> 00:08:10.150
Could have also done this as well,

192
00:08:10.150 --> 00:08:12.300
where we just return,

193
00:08:12.300 --> 00:08:14.520
slug dot to lowercase.

194
00:08:14.520 --> 00:08:15.870
And this case, I kinda like that

195
00:08:15.870 --> 00:08:18.710
because if that regex is complicated,

196
00:08:18.710 --> 00:08:20.610
then you have to update it in two spots.

197
00:08:20.610 --> 00:08:23.358
This is nicer where you can just create the slug,

198
00:08:23.358 --> 00:08:27.070
and then if you are lower casing it,

199
00:08:27.070 --> 00:08:29.320
then you return it with the lowercase value on it.

200
00:08:29.320 --> 00:08:31.100
Otherwise just return the regular slug.

201
00:08:31.100 --> 00:08:35.200
So, many different ways to go about this type of thing.

202
00:08:35.200 --> 00:08:37.350
The important part is that,

203
00:08:37.350 --> 00:08:39.650
when you have an inside of a function,

204
00:08:39.650 --> 00:08:42.600
you can always return from that if,

205
00:08:42.600 --> 00:08:45.090
and that will stop that function from running

206
00:08:45.090 --> 00:08:47.790
and it will actually return the value to the function.

207
00:08:48.880 --> 00:08:50.470
Now let's talk about operators.

208
00:08:50.470 --> 00:08:55.390
We've talked briefly about the different equals science.

209
00:08:55.390 --> 00:08:59.200
So we've got equals triple equals and double equals.

210
00:08:59.200 --> 00:09:00.970
So we have is age variable,

211
00:09:00.970 --> 00:09:04.580
and if we were to check if that is equal to 100,

212
00:09:04.580 --> 00:09:06.150
that will actually error out

213
00:09:06.150 --> 00:09:08.221
because the single equal will set the value into a variable,

214
00:09:08.221 --> 00:09:10.900
and this is a constant variable which you can't do.

215
00:09:10.900 --> 00:09:12.860
Now if I took a double equals,

216
00:09:12.860 --> 00:09:13.970
we get true.

217
00:09:13.970 --> 00:09:15.610
And we learned earlier,

218
00:09:15.610 --> 00:09:18.890
that's because double equals will check that the values

219
00:09:18.890 --> 00:09:19.723
are the same.

220
00:09:19.723 --> 00:09:21.980
So the value of age is 100,

221
00:09:21.980 --> 00:09:24.030
and the value of what we're comparing it against,

222
00:09:24.030 --> 00:09:24.970
it's also 100.

223
00:09:24.970 --> 00:09:25.930
The sort of gotcha there

224
00:09:25.930 --> 00:09:29.500
is if we compare it against another value,

225
00:09:29.500 --> 00:09:33.370
which is something like double equals a string of 100.

226
00:09:33.370 --> 00:09:36.710
Those are technically the same thing,

227
00:09:36.710 --> 00:09:39.250
but they are not the same type.

228
00:09:39.250 --> 00:09:41.160
So using triple equals,

229
00:09:41.160 --> 00:09:45.690
will check if the type of age

230
00:09:45.690 --> 00:09:49.200
and the type of 100

231
00:09:49.200 --> 00:09:50.343
are the same.

232
00:09:51.320 --> 00:09:53.440
I guess I had to put around that (murmur).

233
00:09:53.440 --> 00:09:54.620
So that's a string.

234
00:09:54.620 --> 00:09:56.360
So because of that,

235
00:09:56.360 --> 00:10:00.260
we recommend that you almost always use triple equals.

236
00:10:00.260 --> 00:10:03.450
And I told you that I would be

237
00:10:05.050 --> 00:10:06.520
telling you why

238
00:10:06.520 --> 00:10:09.360
there is double equals in the language.

239
00:10:09.360 --> 00:10:12.300
And that is because of null and undefined.

240
00:10:12.300 --> 00:10:15.530
So sometimes if you have null,

241
00:10:15.530 --> 00:10:18.680
and you wanna check if it's equal to undefined,

242
00:10:18.680 --> 00:10:19.870
that's going to be false.

243
00:10:19.870 --> 00:10:21.620
Wherever a double equals,

244
00:10:21.620 --> 00:10:25.170
those two things are going to be the same.

245
00:10:25.170 --> 00:10:28.760
Now, that's sort of why we have it,

246
00:10:28.760 --> 00:10:30.850
although honestly I can't remember the last time

247
00:10:30.850 --> 00:10:32.390
that I've done that in my career

248
00:10:32.390 --> 00:10:34.830
where I've had to reach for double equals,

249
00:10:34.830 --> 00:10:36.790
because of what we're going to learn in just a second,

250
00:10:36.790 --> 00:10:39.210
which is truthy or falsy.

251
00:10:39.210 --> 00:10:42.970
Now you also have does not equal with bang.

252
00:10:42.970 --> 00:10:45.200
And the bang is the exclamation mark.

253
00:10:45.200 --> 00:10:48.893
So if I say const name is equal to wes,

254
00:10:50.625 --> 00:10:52.380
we say name is equal to wes.

255
00:10:52.380 --> 00:10:54.130
Obviously that's true.

256
00:10:54.130 --> 00:10:56.923
But if I say name is equal to Keith,

257
00:10:58.860 --> 00:11:00.910
that is going to be false.

258
00:11:00.910 --> 00:11:04.300
And now in our case, you can take out one of the equals

259
00:11:04.300 --> 00:11:06.230
and put a bang, an exclamation mark.

260
00:11:06.230 --> 00:11:08.220
Bang is what we call it as programmers.

261
00:11:08.220 --> 00:11:12.930
So name does not equal Keith, and that will be true.

262
00:11:12.930 --> 00:11:14.420
So you can either do it that

263
00:11:14.420 --> 00:11:17.120
with a double equals and one bang,

264
00:11:17.120 --> 00:11:18.920
so that is the best practice,

265
00:11:18.920 --> 00:11:20.394
but it will also work with

266
00:11:20.394 --> 00:11:25.363
10 does not equal 10.

267
00:11:27.870 --> 00:11:28.830
That is true,

268
00:11:28.830 --> 00:11:32.610
but then if I make that a single one little be false.

269
00:11:32.610 --> 00:11:35.860
Why because these things technically are the same

270
00:11:35.860 --> 00:11:37.330
when you're using double equals.

271
00:11:37.330 --> 00:11:38.930
So, that bang in there,

272
00:11:38.930 --> 00:11:41.623
it will check for not equal to.

273
00:11:43.440 --> 00:11:45.470
Of course we have greater than or less than.

274
00:11:45.470 --> 00:11:48.740
So if you are checking like 10 is greater than 10,

275
00:11:48.740 --> 00:11:51.650
10 is greater or equal to 10.

276
00:11:51.650 --> 00:11:53.040
Sometimes people think like okay,

277
00:11:53.040 --> 00:11:55.070
so all the other ones are three characters

278
00:11:55.070 --> 00:11:57.580
like triple equals and bang double equals.

279
00:11:57.580 --> 00:11:59.773
So like wouldn't have to do that.

280
00:12:00.610 --> 00:12:01.530
No, that doesn't work.

281
00:12:01.530 --> 00:12:06.320
Why? Because these greater than less than

282
00:12:06.320 --> 00:12:10.800
and equal to operators only ever deal with numbers.

283
00:12:10.800 --> 00:12:15.800
So if you by chance use a string in there,

284
00:12:17.350 --> 00:12:20.080
it will, what it will do is it will turn the string

285
00:12:20.080 --> 00:12:21.860
into a number at first,

286
00:12:21.860 --> 00:12:23.810
but you shouldn't really be doing that.

287
00:12:23.810 --> 00:12:24.643
You should always make sure

288
00:12:24.643 --> 00:12:25.890
that you've got apples and apples.

289
00:12:25.890 --> 00:12:27.920
You got numbers before you're doing

290
00:12:27.920 --> 00:12:29.410
any sort of type of this thing.

291
00:12:29.410 --> 00:12:32.046
So if I a greater or equal to,

292
00:12:32.046 --> 00:12:36.070
I always tell people think of the hungry alligator.

293
00:12:36.070 --> 00:12:38.250
That's the way I can remember it.

294
00:12:38.250 --> 00:12:40.100
Is the hungry alligator.

295
00:12:40.100 --> 00:12:42.320
See his little mouth?

296
00:12:42.320 --> 00:12:47.250
Is he pointed to the largest number? Then Yes,

297
00:12:47.250 --> 00:12:48.180
that is true.

298
00:12:48.180 --> 00:12:50.560
But if the hungry alligator is mixed up

299
00:12:50.560 --> 00:12:53.490
and he's pointed towards the wrong number,

300
00:12:53.490 --> 00:12:54.876
the smaller number then is going to be false

301
00:12:54.876 --> 00:12:59.876
and that the alligator is no good. (laughs)

302
00:13:01.760 --> 00:13:04.150
Additionally, we have and or, or.

303
00:13:04.150 --> 00:13:05.850
This is something that I do quite a bit.

304
00:13:05.850 --> 00:13:08.150
Let's move back to this HTML here,

305
00:13:08.150 --> 00:13:11.870
so we can sort of see how this all works.

306
00:13:11.870 --> 00:13:14.333
So say const name is equal to wes.

307
00:13:15.530 --> 00:13:18.903
And we want to say if name is equal to wes,

308
00:13:18.903 --> 00:13:22.660
then we say console log, cool name.

309
00:13:22.660 --> 00:13:25.330
Now if I want to code a function

310
00:13:25.330 --> 00:13:28.190
that checked if someone's name was also Scott,

311
00:13:28.190 --> 00:13:30.350
and that also is a cool name,

312
00:13:30.350 --> 00:13:33.846
then I could use the or

313
00:13:33.846 --> 00:13:36.240
in my if statement.

314
00:13:36.240 --> 00:13:39.450
So or looks like this pipe pipe,

315
00:13:39.450 --> 00:13:42.600
and then we say name is equal to Scott.

316
00:13:42.600 --> 00:13:43.835
So a couple things there.

317
00:13:43.835 --> 00:13:47.280
This reads as if the name is equal to Wes,

318
00:13:47.280 --> 00:13:51.423
or the name is equal to Scott then we console a cool name.

319
00:13:52.380 --> 00:13:55.420
And it says cool name, if I change this just to Scott,

320
00:13:55.420 --> 00:13:57.550
it will still say cool name.

321
00:13:57.550 --> 00:13:59.170
Don't worry about the capitalization now,

322
00:13:59.170 --> 00:14:00.340
we'll run into how to say that.

323
00:14:00.340 --> 00:14:02.470
Now if I put a capital S on there, it doesn't work.

324
00:14:02.470 --> 00:14:04.570
Don't worry about that for now.

325
00:14:04.570 --> 00:14:07.660
The other thing wanna know is the last names of console.

326
00:14:07.660 --> 00:14:10.350
Last is equal to bos.

327
00:14:10.350 --> 00:14:13.150
If you want to check if the first name is Wes,

328
00:14:13.150 --> 00:14:17.600
and the last name is equal to bos,

329
00:14:17.600 --> 00:14:20.230
then we don't say or, we say and.

330
00:14:20.230 --> 00:14:22.550
And that's what to ampersands.

331
00:14:22.550 --> 00:14:24.120
So and and.

332
00:14:24.120 --> 00:14:25.560
If the name is equal to wes,

333
00:14:25.560 --> 00:14:27.010
and the last name is equal to bos,

334
00:14:27.010 --> 00:14:28.740
it's not going to run because it's still Scott.

335
00:14:28.740 --> 00:14:31.670
Change that to wes, and it will go ahead and run.

336
00:14:31.670 --> 00:14:33.980
Now another thing about this is that,

337
00:14:33.980 --> 00:14:36.890
we can use (murmur) pretty heavily here.

338
00:14:36.890 --> 00:14:39.363
So we can say if the name is equal to Scott,

339
00:14:40.710 --> 00:14:45.710
or the name is equal to wes

340
00:14:45.900 --> 00:14:49.980
and the last is equal to bos, then cool name.

341
00:14:49.980 --> 00:14:52.370
So if your name is Scott, then you're cool,

342
00:14:52.370 --> 00:14:54.710
but if your name is wes and bos,

343
00:14:54.710 --> 00:14:55.900
then your name is also cool.

344
00:14:55.900 --> 00:14:57.480
So what will this do is,

345
00:14:57.480 --> 00:14:59.480
it will check the parentheses

346
00:14:59.480 --> 00:15:02.040
and this thing needs to be true,

347
00:15:02.040 --> 00:15:03.510
and this thing needs to be true,

348
00:15:03.510 --> 00:15:06.420
in order for the whole thing to be true.

349
00:15:06.420 --> 00:15:08.153
And you can see that here where

350
00:15:08.153 --> 00:15:10.380
if we go in here we say

351
00:15:11.728 --> 00:15:14.810
10 is equal to 10.

352
00:15:14.810 --> 00:15:15.900
That's true.

353
00:15:15.900 --> 00:15:16.733
And 10,

354
00:15:19.610 --> 00:15:21.570
five is equal to five,

355
00:15:21.570 --> 00:15:23.010
that will obviously give us true.

356
00:15:23.010 --> 00:15:26.740
But if one of these is wrong, like three,

357
00:15:26.740 --> 00:15:28.000
it will give us false.

358
00:15:28.000 --> 00:15:29.430
Meaning I always like to think of this

359
00:15:29.430 --> 00:15:31.380
as like poison the well meaning that,

360
00:15:31.380 --> 00:15:33.530
even if everything else was true,

361
00:15:33.530 --> 00:15:35.350
if one of them is false,

362
00:15:35.350 --> 00:15:38.820
then the entire thing will evaluate out to be false.

363
00:15:38.820 --> 00:15:43.820
So that can also be like true and true.

364
00:15:44.230 --> 00:15:47.660
Then we could go forever with this and true and true.

365
00:15:47.660 --> 00:15:50.600
And then as soon as you put that will always equal true.

366
00:15:50.600 --> 00:15:52.730
But if you have one false along the way,

367
00:15:52.730 --> 00:15:54.220
that will poison the well.

368
00:15:54.220 --> 00:15:57.743
Whereas if you had Ors there,

369
00:16:03.040 --> 00:16:04.100
that will always be true

370
00:16:04.100 --> 00:16:07.653
because as long as one of them is going to be equal to true.

371
00:16:08.520 --> 00:16:11.740
Next up we have using functions with if statements.

372
00:16:11.740 --> 00:16:14.930
So, it's pretty common to do something like

373
00:16:14.930 --> 00:16:17.240
if we have a string here,

374
00:16:17.240 --> 00:16:18.073
let's

375
00:16:19.420 --> 00:16:20.993
say wes.

376
00:16:23.260 --> 00:16:24.930
We have a string like awesome,

377
00:16:24.930 --> 00:16:27.010
and we can use that includes,

378
00:16:27.010 --> 00:16:28.930
which is a method on strings.

379
00:16:28.930 --> 00:16:32.610
And we want to say if that includes wes

380
00:16:32.610 --> 00:16:34.070
then it will return true.

381
00:16:34.070 --> 00:16:37.670
If it includes Scott is going to be false.

382
00:16:37.670 --> 00:16:41.270
So includes is a method that will return true or false.

383
00:16:41.270 --> 00:16:44.230
And we can use those directly inside of our if statements.

384
00:16:44.230 --> 00:16:46.970
So we say if awesome

385
00:16:48.560 --> 00:16:50.423
includes the name,

386
00:16:51.280 --> 00:16:53.010
then console log,

387
00:16:53.010 --> 00:16:56.113
super cool awesome name.

388
00:16:58.458 --> 00:17:00.390
Can see super cool awesome name.

389
00:17:00.390 --> 00:17:02.600
Pretty often you have methods that return true or false,

390
00:17:02.600 --> 00:17:05.570
and you can use those directly inside.

391
00:17:05.570 --> 00:17:08.910
You can also sometimes people like to put them

392
00:17:08.910 --> 00:17:12.070
in its own variables, so it makes it easier to read.

393
00:17:12.070 --> 00:17:15.650
So instead of doing that we just make a const is

394
00:17:15.650 --> 00:17:20.650
awesome name and we store the value in a variable,

395
00:17:21.100 --> 00:17:25.080
and then we can say if is awesome name, then go ahead.

396
00:17:25.080 --> 00:17:27.940
So this variable will store a Boolean.

397
00:17:27.940 --> 00:17:29.350
Look at that you have over top on it

398
00:17:29.350 --> 00:17:30.870
it tells you it's a Boolean,

399
00:17:30.870 --> 00:17:32.160
and then we can go ahead and use that.

400
00:17:32.160 --> 00:17:36.980
So readability with multiple and's and or's or if statements

401
00:17:36.980 --> 00:17:39.030
is sometimes gets a little hairy.

402
00:17:39.030 --> 00:17:40.643
So if that's the case,

403
00:17:41.580 --> 00:17:43.610
break it up into separate variables

404
00:17:43.610 --> 00:17:45.320
and then put them into your if statement

405
00:17:45.320 --> 00:17:48.313
because it makes it a lot easier to go ahead and do.

406
00:17:49.310 --> 00:17:51.230
Similarly, we can make our own functions

407
00:17:51.230 --> 00:17:52.570
that return true or false.

408
00:17:52.570 --> 00:17:55.910
So we could just make a function called name is awesome

409
00:17:57.940 --> 00:18:00.050
and that will take in someone's name.

410
00:18:00.050 --> 00:18:04.110
And then from that we can take awesome dot includes

411
00:18:06.290 --> 00:18:07.123
their name.

412
00:18:08.520 --> 00:18:12.220
Then we can simply return the value there.

413
00:18:12.220 --> 00:18:16.230
Now I've got this name is awesome function

414
00:18:16.230 --> 00:18:18.720
that takes in wes and that will return true.

415
00:18:18.720 --> 00:18:21.730
Scott returns false.

416
00:18:21.730 --> 00:18:23.720
You can go ahead and use that in your if statement.

417
00:18:23.720 --> 00:18:28.383
So if name is awesome, Wes,

418
00:18:29.920 --> 00:18:34.173
can console log, cool name Wes.

419
00:18:37.640 --> 00:18:39.563
You see a cool name has pop up there.

420
00:18:41.550 --> 00:18:44.790
Next up, we have this concept of truthy and falsy.

421
00:18:44.790 --> 00:18:48.267
And I haven't been entirely truthy to you,

422
00:18:48.267 --> 00:18:52.210
which is I used to have a mentor of one of my classes named

423
00:18:52.210 --> 00:18:57.210
Truthy and she always we call the truthy the truthy (laughs)

424
00:18:57.210 --> 00:18:58.600
because she always did a good job

425
00:18:58.600 --> 00:19:00.583
at explaining truthy and falsy.

426
00:19:00.583 --> 00:19:04.060
I haven't been entirely truthful in this if statement

427
00:19:04.060 --> 00:19:06.397
is requiring a Boolean cause right here,

428
00:19:06.397 --> 00:19:08.920
that's if statement, that's an if statement.

429
00:19:08.920 --> 00:19:12.370
But because in essence, we will also take values

430
00:19:12.370 --> 00:19:14.430
that are truthy and falsy.

431
00:19:14.430 --> 00:19:18.330
Meaning that if we say const dog

432
00:19:18.330 --> 00:19:20.023
is equal to snickers.

433
00:19:21.680 --> 00:19:26.610
And if we say if dog console log your,

434
00:19:26.610 --> 00:19:29.800
dot you have a dog

435
00:19:29.800 --> 00:19:33.990
and that else you

436
00:19:33.990 --> 00:19:35.293
don't have a dog.

437
00:19:36.810 --> 00:19:38.860
Now if I refresh this, you have a dog.

438
00:19:38.860 --> 00:19:42.593
If I leave Snickers, empty, what's what's going to happen?

439
00:19:43.510 --> 00:19:45.460
You don't have a dog.

440
00:19:45.460 --> 00:19:50.460
Okay? So an empty string is not true

441
00:19:50.890 --> 00:19:52.230
and it's not false.

442
00:19:52.230 --> 00:19:53.600
It's an empty string.

443
00:19:53.600 --> 00:19:55.160
So how come this works?

444
00:19:55.160 --> 00:19:58.300
Well, that's because if statements will take in

445
00:19:58.300 --> 00:20:00.247
a number of different values,

446
00:20:00.247 --> 00:20:03.830
and it will try to coerce them,

447
00:20:03.830 --> 00:20:05.280
that's a word we'll learn about in a second,

448
00:20:05.280 --> 00:20:09.130
it will try to turn them into a Boolean of true or false.

449
00:20:09.130 --> 00:20:12.280
So values that are truthy and falsy will also work.

450
00:20:12.280 --> 00:20:15.810
So what are the truthy and falsy?

451
00:20:15.810 --> 00:20:17.160
So I have a list here.

452
00:20:17.160 --> 00:20:19.630
I'm going to sort them into truthy and falsy.

453
00:20:19.630 --> 00:20:21.320
Let's go up to the body here

454
00:20:21.320 --> 00:20:23.330
and we'll make a h2

455
00:20:24.330 --> 00:20:26.760
truthy values,

456
00:20:26.760 --> 00:20:28.833
and then we'll do falsy values.

457
00:20:30.210 --> 00:20:32.590
And let's just paste the list above it.

458
00:20:32.590 --> 00:20:36.070
Okay, so zero is going to be a falsiy value.

459
00:20:36.070 --> 00:20:38.230
Meaning that when it's run,

460
00:20:38.230 --> 00:20:40.950
a zero will equate to false.

461
00:20:40.950 --> 00:20:44.110
And I can show you real quick example if we go down here,

462
00:20:44.110 --> 00:20:48.290
and we'll say const score is equal to zero.

463
00:20:48.290 --> 00:20:51.270
So if score, log,

464
00:20:51.270 --> 00:20:54.350
there is a score already,

465
00:20:54.350 --> 00:20:58.960
and then else, console log no score yet.

466
00:20:58.960 --> 00:21:02.350
So a score of zero is no score yet.

467
00:21:02.350 --> 00:21:05.750
Why? Because zero equates to false

468
00:21:05.750 --> 00:21:08.260
or it is a falsy value.

469
00:21:08.260 --> 00:21:10.840
One is going to be a truthy value, right?

470
00:21:10.840 --> 00:21:15.283
Because if I change this thing here to one,

471
00:21:16.410 --> 00:21:18.080
there is a score already.

472
00:21:18.080 --> 00:21:20.573
Now what about negative 10?

473
00:21:21.590 --> 00:21:22.920
It's negative.

474
00:21:22.920 --> 00:21:25.479
Is it going to be false or true?

475
00:21:25.479 --> 00:21:27.648
Let's do it.

476
00:21:27.648 --> 00:21:29.650
Let's put its science in place.

477
00:21:29.650 --> 00:21:32.990
A negative 10, place your bets.

478
00:21:32.990 --> 00:21:35.460
Boom, truthy.

479
00:21:35.460 --> 00:21:38.980
So simply zero is falsy,

480
00:21:38.980 --> 00:21:42.343
all other numbers are going to be truthy.

481
00:21:43.410 --> 00:21:44.640
So let's go back

482
00:21:46.290 --> 00:21:48.410
truthy value undefined.

483
00:21:48.410 --> 00:21:52.353
So if, how do you make an undefined variable? Just do that.

484
00:21:54.480 --> 00:21:55.520
We missed our declaration.

485
00:21:55.520 --> 00:21:59.210
You can only make a let be undefined.

486
00:21:59.210 --> 00:22:03.223
So is, if I make undefined variable,

487
00:22:04.160 --> 00:22:05.380
it says no score yet.

488
00:22:05.380 --> 00:22:08.570
So if I go to score, it is undefined.

489
00:22:08.570 --> 00:22:12.433
That means that undefined is a falsy value.

490
00:22:13.490 --> 00:22:16.060
Put it in this list right here.

491
00:22:16.060 --> 00:22:18.650
Next we have a variable set at null.

492
00:22:18.650 --> 00:22:19.990
Null is also a false a value.

493
00:22:19.990 --> 00:22:22.100
I'm not gonna make you do it again.(laughs)

494
00:22:22.100 --> 00:22:23.650
So if you have a variable that is null,

495
00:22:23.650 --> 00:22:25.990
it is the same thing as false,

496
00:22:25.990 --> 00:22:29.910
a variable set to hello minus 10,

497
00:22:29.910 --> 00:22:31.580
which is Nan.

498
00:22:31.580 --> 00:22:34.143
So if we take Hello,

499
00:22:35.230 --> 00:22:36.960
we subtract 10 from it,

500
00:22:36.960 --> 00:22:39.963
we get Nan, which is not a number.

501
00:22:41.230 --> 00:22:45.163
And so is is not a number truthy and falsy.

502
00:22:46.120 --> 00:22:46.963
Let's try it.

503
00:22:48.340 --> 00:22:50.940
The score is equal to

504
00:22:52.890 --> 00:22:55.530
Wes times 100.

505
00:22:55.530 --> 00:22:57.660
That's gonna be Nan. Let's check it.

506
00:22:57.660 --> 00:22:59.710
Score is Nan it says no score yet.

507
00:22:59.710 --> 00:23:04.710
Meaning that Nan is all see an empty string its falsy.

508
00:23:06.060 --> 00:23:06.960
We already learned that.

509
00:23:06.960 --> 00:23:09.020
A full string is truthy.

510
00:23:09.020 --> 00:23:12.330
So any string with content and it will be true.

511
00:23:12.330 --> 00:23:14.143
A string of zero.

512
00:23:16.100 --> 00:23:19.023
So what do you think? Is it what is going to be?

513
00:23:20.686 --> 00:23:23.490
It's a string, and it has content.

514
00:23:23.490 --> 00:23:27.763
So that's true, but we also learned that zero is false.

515
00:23:28.890 --> 00:23:29.850
Already is a score.

516
00:23:29.850 --> 00:23:33.410
So, a string of zero a string of anything,

517
00:23:33.410 --> 00:23:37.720
even a string of space is going to be truthy.

518
00:23:37.720 --> 00:23:40.130
The only thing about a string that is falsy,

519
00:23:40.130 --> 00:23:42.220
is a string of nothing.

520
00:23:42.220 --> 00:23:46.253
So we will put that one under truthy.

521
00:23:47.350 --> 00:23:50.930
Now here is to we really haven't touched on a whole yet.

522
00:23:50.930 --> 00:23:53.470
An empty array and an empty object.

523
00:23:53.470 --> 00:23:57.520
So an array can be shown like this,

524
00:23:57.520 --> 00:23:59.223
with a set of square brackets.

525
00:24:00.330 --> 00:24:04.750
Usually an array of like 1-3-7-8,

526
00:24:04.750 --> 00:24:07.180
and you (murmur) store a list of things in.

527
00:24:07.180 --> 00:24:11.490
We've seen a race before we're going to go into them next.

528
00:24:11.490 --> 00:24:13.960
But if I have an empty array,

529
00:24:13.960 --> 00:24:16.453
well let's look at an array with values in.

530
00:24:18.712 --> 00:24:20.970
It says there is a score so that's truthy.

531
00:24:20.970 --> 00:24:23.853
But if we have an array of nothing,

532
00:24:25.760 --> 00:24:27.000
it says there's a score ready.

533
00:24:27.000 --> 00:24:30.770
So an array that has nothing in it is truthy,

534
00:24:30.770 --> 00:24:34.780
if you ever need to check for anything in an array,

535
00:24:34.780 --> 00:24:37.400
we would look for something called the length.

536
00:24:37.400 --> 00:24:38.840
We're getting a bit ahead of ourselves,

537
00:24:38.840 --> 00:24:41.090
but the length is how you tell how many items

538
00:24:41.090 --> 00:24:42.220
are in an array.

539
00:24:42.220 --> 00:24:44.740
If that's the case, the length will return zero.

540
00:24:44.740 --> 00:24:47.660
So 5 an array 1-2-3,

541
00:24:47.660 --> 00:24:48.960
and the call length on it.

542
00:24:50.200 --> 00:24:51.410
It will give us three.

543
00:24:51.410 --> 00:24:54.760
You have an empty array, with length, it will give us zero.

544
00:24:54.760 --> 00:24:56.140
So that would be true,

545
00:24:56.140 --> 00:24:57.680
that will be false.

546
00:24:57.680 --> 00:24:59.720
Truthy and falsy bring that back.

547
00:24:59.720 --> 00:25:03.190
The Last one that we have is a empty object,

548
00:25:03.190 --> 00:25:04.690
which is curly brackets.

549
00:25:04.690 --> 00:25:06.930
And that works exactly the same,

550
00:25:06.930 --> 00:25:10.990
where you simply an empty object still is truthy,

551
00:25:10.990 --> 00:25:12.150
because it is there.

552
00:25:12.150 --> 00:25:16.290
If you do want to check if there is anything in that object,

553
00:25:16.290 --> 00:25:19.150
you can use something called object dot keys.

554
00:25:19.150 --> 00:25:21.230
So object dot keys

555
00:25:22.230 --> 00:25:24.730
with an empty object

556
00:25:25.720 --> 00:25:27.720
or turned to an empty array,

557
00:25:27.720 --> 00:25:30.420
and then you can just say length on that, and that's zero.

558
00:25:30.420 --> 00:25:34.610
Whereas if we have something like names equal to Wes,

559
00:25:34.610 --> 00:25:36.500
that will give us, object dot keys

560
00:25:36.500 --> 00:25:38.850
will give us all of the properties on it.

561
00:25:38.850 --> 00:25:40.360
And then since it's an array,

562
00:25:40.360 --> 00:25:42.870
we can check for the length on that array.

563
00:25:42.870 --> 00:25:46.160
That's a good way to get true truth the falsy values,

564
00:25:46.160 --> 00:25:47.510
out of an object.

565
00:25:47.510 --> 00:25:49.663
So truthy and falsy.

566
00:25:50.690 --> 00:25:53.240
We use it a whole bunch in JavaScript.

567
00:25:53.240 --> 00:25:54.200
I use that all the time

568
00:25:54.200 --> 00:25:58.050
and that's why you often see if statements with things

569
00:25:58.050 --> 00:25:59.950
that you might not think are true or false.

570
00:25:59.950 --> 00:26:03.300
And that's simply because we're checking for its existence

571
00:26:03.300 --> 00:26:05.470
or checking if it's there or not.

572
00:26:05.470 --> 00:26:06.920
Passing, you can quit this video now

573
00:26:06.920 --> 00:26:08.510
if you're if you understand it.

574
00:26:08.510 --> 00:26:09.343
But what I wanna do

575
00:26:09.343 --> 00:26:11.470
is make an array of all of these different types

576
00:26:11.470 --> 00:26:12.380
and loop over it

577
00:26:12.380 --> 00:26:14.500
and just show you with an if statement

578
00:26:14.500 --> 00:26:16.420
that they are truthy and falsy.

579
00:26:16.420 --> 00:26:20.090
So let's, I'm gonna grab all of these

580
00:26:20.090 --> 00:26:21.670
and all of these,

581
00:26:21.670 --> 00:26:22.560
and

582
00:26:22.560 --> 00:26:24.160
all of these,

583
00:26:24.160 --> 00:26:25.417
and all the way down here.

584
00:26:25.417 --> 00:26:26.850
And we haven't hit arrays yet,

585
00:26:26.850 --> 00:26:28.660
but array is a list of things,

586
00:26:28.660 --> 00:26:30.010
and what we can do is, say,

587
00:26:31.518 --> 00:26:33.950
const values is equal to an empty array,

588
00:26:33.950 --> 00:26:34.820
and then I'm just gonna kinda

589
00:26:34.820 --> 00:26:38.360
go through all of these right now.

590
00:26:38.360 --> 00:26:40.003
So first item is empty array,

591
00:26:40.890 --> 00:26:42.830
a second item is an empty object,

592
00:26:42.830 --> 00:26:45.440
third item is negative 10,

593
00:26:45.440 --> 00:26:48.870
fourth item is one then we have zero,

594
00:26:48.870 --> 00:26:50.630
a empty string,

595
00:26:50.630 --> 00:26:53.820
a full string,

596
00:26:53.820 --> 00:26:56.633
I think we also mentioned a string with a space in it,

597
00:26:57.930 --> 00:27:02.930
undefined, Nan, not, that's case sensitive, not a number.

598
00:27:04.630 --> 00:27:05.463
Null,

599
00:27:07.620 --> 00:27:10.680
and I believe that is it.

600
00:27:10.680 --> 00:27:12.260
So then we'll just take the values

601
00:27:12.260 --> 00:27:17.260
and we'll call for each much like we did with the DOM notes.

602
00:27:17.790 --> 00:27:20.070
And we'll say for each value,

603
00:27:20.070 --> 00:27:22.083
and just console log the value.

604
00:27:23.332 --> 00:27:27.563
So you got here, let's actually console group,

605
00:27:30.980 --> 00:27:34.050
truthy or falsy values

606
00:27:35.020 --> 00:27:35.883
group and

607
00:27:40.220 --> 00:27:41.053
here we go.

608
00:27:41.053 --> 00:27:43.070
And then for each one will say,

609
00:27:43.070 --> 00:27:46.930
if value, then console log,

610
00:27:46.930 --> 00:27:47.763
the value

611
00:27:48.830 --> 00:27:50.783
is truthy.

612
00:27:52.760 --> 00:27:53.593
Else

613
00:27:55.430 --> 00:27:59.793
the value is falsy.

614
00:28:00.770 --> 00:28:04.363
So there we go truthy, truthy, truthy, truthy, falsy.

615
00:28:05.299 --> 00:28:06.132
(laughs)

616
00:28:06.132 --> 00:28:08.080
Doesn't really show us what it is,

617
00:28:08.080 --> 00:28:12.260
but obviously is a an empty string, full string

618
00:28:17.260 --> 00:28:18.993
is space, is truthy.

619
00:28:19.850 --> 00:28:22.300
Undefined as falsy, Nan is fally, null is falsy.

620
00:28:22.300 --> 00:28:24.255
So maybe I don't know maybe get a tattoo of that

621
00:28:24.255 --> 00:28:28.120
on your chest or print it out put upside your computer.

622
00:28:28.120 --> 00:28:31.843
It is kinda of just a nice little look at all their values.

623
00:28:31.843 --> 00:28:33.220
Then the kind of thing about that

624
00:28:33.220 --> 00:28:35.300
is you can add you can add anything you want.

625
00:28:35.300 --> 00:28:40.300
Like is a, an emoji of zero truthy a falsy?

626
00:28:42.470 --> 00:28:43.497
truthy

627
00:28:43.497 --> 00:28:48.497
(laughs) is a actually the only emoji that is falsy,

628
00:28:49.130 --> 00:28:50.523
is the poop emoji.

629
00:28:51.920 --> 00:28:53.099
I'm joking and just joking.

630
00:28:53.099 --> 00:28:54.730
They're all truthy.

631
00:28:54.730 --> 00:28:55.563
They're all texts.

632
00:28:55.563 --> 00:28:57.380
They're all something so they are truthy.

633
00:28:57.380 --> 00:28:59.960
So next video we're going to get into coersion

634
00:28:59.960 --> 00:29:03.050
and ternaries.

635
00:29:03.050 --> 00:29:03.883
See you then.

